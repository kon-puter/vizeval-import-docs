\section{Pou쬴t칠 technologie}
\improvement{po콏치d se opakuje pou쮂셨치me, prvn칤 osoba na popis postupu 游}

Pou쮂셨치me framework \href{https://symfony.com/}{Symfony}. Symfony je open-source PHP framework, kter칳 je vyd치n pod MIT licenc칤.  Vyu쮂셨치 n치vrhov칳 vzor MVC a modern칤 PHP. Symfony je modul치rn칤 a jednodu코e roz코i콏iteln칳 pomoc칤 existuj칤c칤ch bundl콢/component콢. To je jeden z hlavn칤ch d콢vod콢, pro캜 byl tento framework vybr치n. Ji spoustu probl칠m콢 콏e코칤 za n치s a zamezuje t칤m bezpe캜nostn칤m a jin칳m chyb치m.
Za zm칤켿ku stoj칤 Symfony EasyAdmin, kter칳 dok치쬰 vytvo콏it pro danou entitu CRUD str치nku, kter치 je jednodu코e upraviteln치.

\subsection{Datab치ze}
Pou쮂셨치me Symfony spole캜n캩 s Doctrine ORM, to n치m poskytuje 콏adu v칳hod jako typesafe mapov치n칤, nez치vislost na datab치zi\footnote{Doctrine ORM aktu치ln캩 podporuje PostgreSQL, MySQL, Oracle, SQL server a dal코칤\cite{doctrine-supported-dbs}}. S Doctrine pou쮂셨치me p콏칤stup code first, nap칤코eme standardn칤 PHP t콏칤du, kde pomoc칤 atribut콢 p콏id치me vlastnostem informace o jejich mapov치n칤. 
\unsure{Pridat example}
Pro uchov치v치n칤 dat pou쮂셨치me rela캜n칤 datab치zi PostgreSQL, ta podporuje  pokro캜ilej코칤 funkce jako transakce DDL narozd칤l od MySQL.  

\subsection{Serverov칠 technologie}
Jako web server pou쮂셨치me FrankenPHP, modern칤 php server zalo쬰n칳 na serveru Caddy. FrankenPHP podporuje worker mode, kter칳 umo쮄갓je znovu pou쬴t칤 PHP interpretoru p콏i dal코칤m requestu.

Na코e aplikace je nasazov치na pomoc칤 dockeru. Pro ka쬯ou 코kolu m치me zvl치코콘 container s datab치zov칳m a webov칳m serverem.
Jako reverse proxy pou쮂셨치me Traefic, kter칳 n치m umo쮄갓je jednoduchou spr치vu instanc칤.

\subsection{Frontendov칠 technologie}

U importu pou쮂셨치m bal칤ky z iniciativy \href{https://ux.symfony.com/}{Symfony UX} jako forntendov칠 콏e코en칤.
Cel칳 import obsahuje 칰pln칠 minimum JavaScriptu, ten je nav칤c ve Stimulus controllerech. Ozna캜칤 se HTML element, na kter칳 chci aby se kontroler p콏ipojil a potom m치m p콏칤stup k target콢m dan칠ho kontroleru.
Taky pou쮂셨치m Hotwire Turbo\label{ux-turbo}, kter칠 jednodu코e napodobuje funkcionalitu SPA, Turbo funguje skv캩le se Stimulusem.
Na n캩kter칠 캜치sti pou쮂셨치m LiveComponent, co je n캩co jako Phoenix LiveWire, kde je u쬴vatelsk칠 rozhran칤 콏칤zeno p콏칤mo ze strany serveru. 
N캩kter칠 formul치콏e jsou sestavovan칠 pomoc칤 Symfony Form, ten se potom star치 o mapov치n칤 vstupu a validaci\footnote{Na validaci pou쮂셨치 Symfony Validator.}.
Symfony Form vygeneruje p콏칤mo HTML form se v코emi pot콏ebn칳mi n치le쬴tostmi jako zpracov치n칤 chyb a stylov치n칤\footnote{Jako styl je mo쬹o specifikovat template. My pou쮂셨치me Bootstrap}, taky zamezuje XSRF 칰tok콢m\footnote{Do formul치콏e vkl치d치 XSRF token, kter칳 potom validuje.}.

  \subsection{Kone캜n칳 automat}\label{uvod:konecny-automat}

Je abstraktn칤 automat, kter칳 m콢쬰 b칳t v p콏치v캩 jednom stavu.\cite{wiki:finite-state-machine-en} Kdy automat p콏ech치z칤 z jednoho stavu do druh칠ho naz칳v치 se to p콏echod.
Automat se naz칳v치 kone캜n칳m, proto쬰 m치 jen kone캜n칳 po캜et stav콢.
Vyu쮂셨aj칤 se pro parsov치n칤 form치ln칤ch jazyk콢 a jsou u쬴te캜n칠 p콏i modelov치n칤 logiky aplikace.
Mezi jin치 vyu쬴t칤 pat콏칤 parsov치n칤 regularn칤ch v칳raz콢.\cite{wiki:finite-state-machine-cz}

Jako implementaci kone캜n칠ho automatu pou쮂셨치m Symfony Workflow.
Taky je kone캜n칳 automat pou쮂셨치n p콏i zv칳raz켿ov치n칤 v칳raz콢 pro generov치n칤 email콢 v editoru Ace.


